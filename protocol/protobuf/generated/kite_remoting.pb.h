// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kite_remoting.proto

#ifndef PROTOBUF_kite_5fremoting_2eproto__INCLUDED
#define PROTOBUF_kite_5fremoting_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_kite_5fremoting_2eproto();
void protobuf_AssignDesc_kite_5fremoting_2eproto();
void protobuf_ShutdownFile_kite_5fremoting_2eproto();

class BytesMessage;
class ConnAuthAck;
class ConnMeta;
class DeliverAck;
class Entry;
class Header;
class HeartBeat;
class MessageStoreAck;
class StringMessage;
class TxACKPacket;

// ===================================================================

class HeartBeat : public ::google::protobuf::Message {
 public:
  HeartBeat();
  virtual ~HeartBeat();

  HeartBeat(const HeartBeat& from);

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeat& default_instance();

  void Swap(HeartBeat* other);

  // implements Message ----------------------------------------------

  inline HeartBeat* New() const { return New(NULL); }

  HeartBeat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartBeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:HeartBeat)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 version_;
  friend void  protobuf_AddDesc_kite_5fremoting_2eproto();
  friend void protobuf_AssignDesc_kite_5fremoting_2eproto();
  friend void protobuf_ShutdownFile_kite_5fremoting_2eproto();

  void InitAsDefaultInstance();
  static HeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class ConnMeta : public ::google::protobuf::Message {
 public:
  ConnMeta();
  virtual ~ConnMeta();

  ConnMeta(const ConnMeta& from);

  inline ConnMeta& operator=(const ConnMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnMeta& default_instance();

  void Swap(ConnMeta* other);

  // implements Message ----------------------------------------------

  inline ConnMeta* New() const { return New(NULL); }

  ConnMeta* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnMeta& from);
  void MergeFrom(const ConnMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string groupId = 1;
  bool has_groupid() const;
  void clear_groupid();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& groupid() const;
  void set_groupid(const ::std::string& value);
  void set_groupid(const char* value);
  void set_groupid(const char* value, size_t size);
  ::std::string* mutable_groupid();
  ::std::string* release_groupid();
  void set_allocated_groupid(::std::string* groupid);

  // required string secretKey = 2;
  bool has_secretkey() const;
  void clear_secretkey();
  static const int kSecretKeyFieldNumber = 2;
  const ::std::string& secretkey() const;
  void set_secretkey(const ::std::string& value);
  void set_secretkey(const char* value);
  void set_secretkey(const char* value, size_t size);
  ::std::string* mutable_secretkey();
  ::std::string* release_secretkey();
  void set_allocated_secretkey(::std::string* secretkey);

  // @@protoc_insertion_point(class_scope:ConnMeta)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_secretkey();
  inline void clear_has_secretkey();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr groupid_;
  ::google::protobuf::internal::ArenaStringPtr secretkey_;
  friend void  protobuf_AddDesc_kite_5fremoting_2eproto();
  friend void protobuf_AssignDesc_kite_5fremoting_2eproto();
  friend void protobuf_ShutdownFile_kite_5fremoting_2eproto();

  void InitAsDefaultInstance();
  static ConnMeta* default_instance_;
};
// -------------------------------------------------------------------

class ConnAuthAck : public ::google::protobuf::Message {
 public:
  ConnAuthAck();
  virtual ~ConnAuthAck();

  ConnAuthAck(const ConnAuthAck& from);

  inline ConnAuthAck& operator=(const ConnAuthAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnAuthAck& default_instance();

  void Swap(ConnAuthAck* other);

  // implements Message ----------------------------------------------

  inline ConnAuthAck* New() const { return New(NULL); }

  ConnAuthAck* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnAuthAck& from);
  void MergeFrom(const ConnAuthAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnAuthAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool status = 1 [default = true];
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  bool status() const;
  void set_status(bool value);

  // required string feedback = 2;
  bool has_feedback() const;
  void clear_feedback();
  static const int kFeedbackFieldNumber = 2;
  const ::std::string& feedback() const;
  void set_feedback(const ::std::string& value);
  void set_feedback(const char* value);
  void set_feedback(const char* value, size_t size);
  ::std::string* mutable_feedback();
  ::std::string* release_feedback();
  void set_allocated_feedback(::std::string* feedback);

  // @@protoc_insertion_point(class_scope:ConnAuthAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_feedback();
  inline void clear_has_feedback();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr feedback_;
  bool status_;
  friend void  protobuf_AddDesc_kite_5fremoting_2eproto();
  friend void protobuf_AssignDesc_kite_5fremoting_2eproto();
  friend void protobuf_ShutdownFile_kite_5fremoting_2eproto();

  void InitAsDefaultInstance();
  static ConnAuthAck* default_instance_;
};
// -------------------------------------------------------------------

class MessageStoreAck : public ::google::protobuf::Message {
 public:
  MessageStoreAck();
  virtual ~MessageStoreAck();

  MessageStoreAck(const MessageStoreAck& from);

  inline MessageStoreAck& operator=(const MessageStoreAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageStoreAck& default_instance();

  void Swap(MessageStoreAck* other);

  // implements Message ----------------------------------------------

  inline MessageStoreAck* New() const { return New(NULL); }

  MessageStoreAck* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageStoreAck& from);
  void MergeFrom(const MessageStoreAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageStoreAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string messageId = 1;
  bool has_messageid() const;
  void clear_messageid();
  static const int kMessageIdFieldNumber = 1;
  const ::std::string& messageid() const;
  void set_messageid(const ::std::string& value);
  void set_messageid(const char* value);
  void set_messageid(const char* value, size_t size);
  ::std::string* mutable_messageid();
  ::std::string* release_messageid();
  void set_allocated_messageid(::std::string* messageid);

  // required bool status = 2 [default = true];
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  bool status() const;
  void set_status(bool value);

  // required string feedback = 3;
  bool has_feedback() const;
  void clear_feedback();
  static const int kFeedbackFieldNumber = 3;
  const ::std::string& feedback() const;
  void set_feedback(const ::std::string& value);
  void set_feedback(const char* value);
  void set_feedback(const char* value, size_t size);
  ::std::string* mutable_feedback();
  ::std::string* release_feedback();
  void set_allocated_feedback(::std::string* feedback);

  // @@protoc_insertion_point(class_scope:MessageStoreAck)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_feedback();
  inline void clear_has_feedback();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messageid_;
  ::google::protobuf::internal::ArenaStringPtr feedback_;
  bool status_;
  friend void  protobuf_AddDesc_kite_5fremoting_2eproto();
  friend void protobuf_AssignDesc_kite_5fremoting_2eproto();
  friend void protobuf_ShutdownFile_kite_5fremoting_2eproto();

  void InitAsDefaultInstance();
  static MessageStoreAck* default_instance_;
};
// -------------------------------------------------------------------

class DeliverAck : public ::google::protobuf::Message {
 public:
  DeliverAck();
  virtual ~DeliverAck();

  DeliverAck(const DeliverAck& from);

  inline DeliverAck& operator=(const DeliverAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeliverAck& default_instance();

  void Swap(DeliverAck* other);

  // implements Message ----------------------------------------------

  inline DeliverAck* New() const { return New(NULL); }

  DeliverAck* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeliverAck& from);
  void MergeFrom(const DeliverAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeliverAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string messageId = 1;
  bool has_messageid() const;
  void clear_messageid();
  static const int kMessageIdFieldNumber = 1;
  const ::std::string& messageid() const;
  void set_messageid(const ::std::string& value);
  void set_messageid(const char* value);
  void set_messageid(const char* value, size_t size);
  ::std::string* mutable_messageid();
  ::std::string* release_messageid();
  void set_allocated_messageid(::std::string* messageid);

  // required string topic = 2;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 2;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // required string messageType = 3;
  bool has_messagetype() const;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 3;
  const ::std::string& messagetype() const;
  void set_messagetype(const ::std::string& value);
  void set_messagetype(const char* value);
  void set_messagetype(const char* value, size_t size);
  ::std::string* mutable_messagetype();
  ::std::string* release_messagetype();
  void set_allocated_messagetype(::std::string* messagetype);

  // required string groupId = 4;
  bool has_groupid() const;
  void clear_groupid();
  static const int kGroupIdFieldNumber = 4;
  const ::std::string& groupid() const;
  void set_groupid(const ::std::string& value);
  void set_groupid(const char* value);
  void set_groupid(const char* value, size_t size);
  ::std::string* mutable_groupid();
  ::std::string* release_groupid();
  void set_allocated_groupid(::std::string* groupid);

  // required bool status = 5 [default = true];
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  bool status() const;
  void set_status(bool value);

  // @@protoc_insertion_point(class_scope:DeliverAck)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_status();
  inline void clear_has_status();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messageid_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr messagetype_;
  ::google::protobuf::internal::ArenaStringPtr groupid_;
  bool status_;
  friend void  protobuf_AddDesc_kite_5fremoting_2eproto();
  friend void protobuf_AssignDesc_kite_5fremoting_2eproto();
  friend void protobuf_ShutdownFile_kite_5fremoting_2eproto();

  void InitAsDefaultInstance();
  static DeliverAck* default_instance_;
};
// -------------------------------------------------------------------

class TxACKPacket : public ::google::protobuf::Message {
 public:
  TxACKPacket();
  virtual ~TxACKPacket();

  TxACKPacket(const TxACKPacket& from);

  inline TxACKPacket& operator=(const TxACKPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxACKPacket& default_instance();

  void Swap(TxACKPacket* other);

  // implements Message ----------------------------------------------

  inline TxACKPacket* New() const { return New(NULL); }

  TxACKPacket* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxACKPacket& from);
  void MergeFrom(const TxACKPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxACKPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::Header& header() const;
  ::Header* mutable_header();
  ::Header* release_header();
  void set_allocated_header(::Header* header);

  // required int32 status = 2 [default = 0];
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // required string feedback = 3;
  bool has_feedback() const;
  void clear_feedback();
  static const int kFeedbackFieldNumber = 3;
  const ::std::string& feedback() const;
  void set_feedback(const ::std::string& value);
  void set_feedback(const char* value);
  void set_feedback(const char* value, size_t size);
  ::std::string* mutable_feedback();
  ::std::string* release_feedback();
  void set_allocated_feedback(::std::string* feedback);

  // @@protoc_insertion_point(class_scope:TxACKPacket)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_feedback();
  inline void clear_has_feedback();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Header* header_;
  ::google::protobuf::internal::ArenaStringPtr feedback_;
  ::google::protobuf::int32 status_;
  friend void  protobuf_AddDesc_kite_5fremoting_2eproto();
  friend void protobuf_AssignDesc_kite_5fremoting_2eproto();
  friend void protobuf_ShutdownFile_kite_5fremoting_2eproto();

  void InitAsDefaultInstance();
  static TxACKPacket* default_instance_;
};
// -------------------------------------------------------------------

class Entry : public ::google::protobuf::Message {
 public:
  Entry();
  virtual ~Entry();

  Entry(const Entry& from);

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entry& default_instance();

  void Swap(Entry* other);

  // implements Message ----------------------------------------------

  inline Entry* New() const { return New(NULL); }

  Entry* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entry& from);
  void MergeFrom(const Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Entry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Entry)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_AddDesc_kite_5fremoting_2eproto();
  friend void protobuf_AssignDesc_kite_5fremoting_2eproto();
  friend void protobuf_ShutdownFile_kite_5fremoting_2eproto();

  void InitAsDefaultInstance();
  static Entry* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  inline Header* New() const { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string messageId = 1;
  bool has_messageid() const;
  void clear_messageid();
  static const int kMessageIdFieldNumber = 1;
  const ::std::string& messageid() const;
  void set_messageid(const ::std::string& value);
  void set_messageid(const char* value);
  void set_messageid(const char* value, size_t size);
  ::std::string* mutable_messageid();
  ::std::string* release_messageid();
  void set_allocated_messageid(::std::string* messageid);

  // required string topic = 2;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 2;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // required string messageType = 3;
  bool has_messagetype() const;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 3;
  const ::std::string& messagetype() const;
  void set_messagetype(const ::std::string& value);
  void set_messagetype(const char* value);
  void set_messagetype(const char* value, size_t size);
  ::std::string* mutable_messagetype();
  ::std::string* release_messagetype();
  void set_allocated_messagetype(::std::string* messagetype);

  // required int64 expiredTime = 4 [default = -1];
  bool has_expiredtime() const;
  void clear_expiredtime();
  static const int kExpiredTimeFieldNumber = 4;
  ::google::protobuf::int64 expiredtime() const;
  void set_expiredtime(::google::protobuf::int64 value);

  // required int32 deliverLimit = 5 [default = 100];
  bool has_deliverlimit() const;
  void clear_deliverlimit();
  static const int kDeliverLimitFieldNumber = 5;
  ::google::protobuf::int32 deliverlimit() const;
  void set_deliverlimit(::google::protobuf::int32 value);

  // required string groupId = 6;
  bool has_groupid() const;
  void clear_groupid();
  static const int kGroupIdFieldNumber = 6;
  const ::std::string& groupid() const;
  void set_groupid(const ::std::string& value);
  void set_groupid(const char* value);
  void set_groupid(const char* value, size_t size);
  ::std::string* mutable_groupid();
  ::std::string* release_groupid();
  void set_allocated_groupid(::std::string* groupid);

  // required bool commit = 7;
  bool has_commit() const;
  void clear_commit();
  static const int kCommitFieldNumber = 7;
  bool commit() const;
  void set_commit(bool value);

  // required bool fly = 8 [default = false];
  bool has_fly() const;
  void clear_fly();
  static const int kFlyFieldNumber = 8;
  bool fly() const;
  void set_fly(bool value);

  // repeated .Entry properties = 9;
  int properties_size() const;
  void clear_properties();
  static const int kPropertiesFieldNumber = 9;
  const ::Entry& properties(int index) const;
  ::Entry* mutable_properties(int index);
  ::Entry* add_properties();
  ::google::protobuf::RepeatedPtrField< ::Entry >*
      mutable_properties();
  const ::google::protobuf::RepeatedPtrField< ::Entry >&
      properties() const;

  // @@protoc_insertion_point(class_scope:Header)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_expiredtime();
  inline void clear_has_expiredtime();
  inline void set_has_deliverlimit();
  inline void clear_has_deliverlimit();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_commit();
  inline void clear_has_commit();
  inline void set_has_fly();
  inline void clear_has_fly();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messageid_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr messagetype_;
  ::google::protobuf::int64 expiredtime_;
  ::google::protobuf::internal::ArenaStringPtr groupid_;
  ::google::protobuf::int32 deliverlimit_;
  bool commit_;
  bool fly_;
  ::google::protobuf::RepeatedPtrField< ::Entry > properties_;
  friend void  protobuf_AddDesc_kite_5fremoting_2eproto();
  friend void protobuf_AssignDesc_kite_5fremoting_2eproto();
  friend void protobuf_ShutdownFile_kite_5fremoting_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class BytesMessage : public ::google::protobuf::Message {
 public:
  BytesMessage();
  virtual ~BytesMessage();

  BytesMessage(const BytesMessage& from);

  inline BytesMessage& operator=(const BytesMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytesMessage& default_instance();

  void Swap(BytesMessage* other);

  // implements Message ----------------------------------------------

  inline BytesMessage* New() const { return New(NULL); }

  BytesMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BytesMessage& from);
  void MergeFrom(const BytesMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BytesMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::Header& header() const;
  ::Header* mutable_header();
  ::Header* release_header();
  void set_allocated_header(::Header* header);

  // required bytes body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:BytesMessage)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Header* header_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  friend void  protobuf_AddDesc_kite_5fremoting_2eproto();
  friend void protobuf_AssignDesc_kite_5fremoting_2eproto();
  friend void protobuf_ShutdownFile_kite_5fremoting_2eproto();

  void InitAsDefaultInstance();
  static BytesMessage* default_instance_;
};
// -------------------------------------------------------------------

class StringMessage : public ::google::protobuf::Message {
 public:
  StringMessage();
  virtual ~StringMessage();

  StringMessage(const StringMessage& from);

  inline StringMessage& operator=(const StringMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringMessage& default_instance();

  void Swap(StringMessage* other);

  // implements Message ----------------------------------------------

  inline StringMessage* New() const { return New(NULL); }

  StringMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringMessage& from);
  void MergeFrom(const StringMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::Header& header() const;
  ::Header* mutable_header();
  ::Header* release_header();
  void set_allocated_header(::Header* header);

  // required string body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  void set_body(const char* value);
  void set_body(const char* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:StringMessage)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Header* header_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  friend void  protobuf_AddDesc_kite_5fremoting_2eproto();
  friend void protobuf_AssignDesc_kite_5fremoting_2eproto();
  friend void protobuf_ShutdownFile_kite_5fremoting_2eproto();

  void InitAsDefaultInstance();
  static StringMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// HeartBeat

// required int64 version = 1;
inline bool HeartBeat::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartBeat::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartBeat::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartBeat::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::int64 HeartBeat::version() const {
  // @@protoc_insertion_point(field_get:HeartBeat.version)
  return version_;
}
inline void HeartBeat::set_version(::google::protobuf::int64 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:HeartBeat.version)
}

// -------------------------------------------------------------------

// ConnMeta

// required string groupId = 1;
inline bool ConnMeta::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnMeta::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnMeta::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnMeta::clear_groupid() {
  groupid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupid();
}
inline const ::std::string& ConnMeta::groupid() const {
  // @@protoc_insertion_point(field_get:ConnMeta.groupId)
  return groupid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnMeta::set_groupid(const ::std::string& value) {
  set_has_groupid();
  groupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ConnMeta.groupId)
}
inline void ConnMeta::set_groupid(const char* value) {
  set_has_groupid();
  groupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ConnMeta.groupId)
}
inline void ConnMeta::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  groupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ConnMeta.groupId)
}
inline ::std::string* ConnMeta::mutable_groupid() {
  set_has_groupid();
  // @@protoc_insertion_point(field_mutable:ConnMeta.groupId)
  return groupid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnMeta::release_groupid() {
  clear_has_groupid();
  return groupid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnMeta::set_allocated_groupid(::std::string* groupid) {
  if (groupid != NULL) {
    set_has_groupid();
  } else {
    clear_has_groupid();
  }
  groupid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupid);
  // @@protoc_insertion_point(field_set_allocated:ConnMeta.groupId)
}

// required string secretKey = 2;
inline bool ConnMeta::has_secretkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnMeta::set_has_secretkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnMeta::clear_has_secretkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnMeta::clear_secretkey() {
  secretkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_secretkey();
}
inline const ::std::string& ConnMeta::secretkey() const {
  // @@protoc_insertion_point(field_get:ConnMeta.secretKey)
  return secretkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnMeta::set_secretkey(const ::std::string& value) {
  set_has_secretkey();
  secretkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ConnMeta.secretKey)
}
inline void ConnMeta::set_secretkey(const char* value) {
  set_has_secretkey();
  secretkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ConnMeta.secretKey)
}
inline void ConnMeta::set_secretkey(const char* value, size_t size) {
  set_has_secretkey();
  secretkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ConnMeta.secretKey)
}
inline ::std::string* ConnMeta::mutable_secretkey() {
  set_has_secretkey();
  // @@protoc_insertion_point(field_mutable:ConnMeta.secretKey)
  return secretkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnMeta::release_secretkey() {
  clear_has_secretkey();
  return secretkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnMeta::set_allocated_secretkey(::std::string* secretkey) {
  if (secretkey != NULL) {
    set_has_secretkey();
  } else {
    clear_has_secretkey();
  }
  secretkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secretkey);
  // @@protoc_insertion_point(field_set_allocated:ConnMeta.secretKey)
}

// -------------------------------------------------------------------

// ConnAuthAck

// required bool status = 1 [default = true];
inline bool ConnAuthAck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnAuthAck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnAuthAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnAuthAck::clear_status() {
  status_ = true;
  clear_has_status();
}
inline bool ConnAuthAck::status() const {
  // @@protoc_insertion_point(field_get:ConnAuthAck.status)
  return status_;
}
inline void ConnAuthAck::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:ConnAuthAck.status)
}

// required string feedback = 2;
inline bool ConnAuthAck::has_feedback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnAuthAck::set_has_feedback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnAuthAck::clear_has_feedback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnAuthAck::clear_feedback() {
  feedback_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_feedback();
}
inline const ::std::string& ConnAuthAck::feedback() const {
  // @@protoc_insertion_point(field_get:ConnAuthAck.feedback)
  return feedback_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnAuthAck::set_feedback(const ::std::string& value) {
  set_has_feedback();
  feedback_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ConnAuthAck.feedback)
}
inline void ConnAuthAck::set_feedback(const char* value) {
  set_has_feedback();
  feedback_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ConnAuthAck.feedback)
}
inline void ConnAuthAck::set_feedback(const char* value, size_t size) {
  set_has_feedback();
  feedback_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ConnAuthAck.feedback)
}
inline ::std::string* ConnAuthAck::mutable_feedback() {
  set_has_feedback();
  // @@protoc_insertion_point(field_mutable:ConnAuthAck.feedback)
  return feedback_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnAuthAck::release_feedback() {
  clear_has_feedback();
  return feedback_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnAuthAck::set_allocated_feedback(::std::string* feedback) {
  if (feedback != NULL) {
    set_has_feedback();
  } else {
    clear_has_feedback();
  }
  feedback_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), feedback);
  // @@protoc_insertion_point(field_set_allocated:ConnAuthAck.feedback)
}

// -------------------------------------------------------------------

// MessageStoreAck

// required string messageId = 1;
inline bool MessageStoreAck::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageStoreAck::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageStoreAck::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageStoreAck::clear_messageid() {
  messageid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messageid();
}
inline const ::std::string& MessageStoreAck::messageid() const {
  // @@protoc_insertion_point(field_get:MessageStoreAck.messageId)
  return messageid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageStoreAck::set_messageid(const ::std::string& value) {
  set_has_messageid();
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageStoreAck.messageId)
}
inline void MessageStoreAck::set_messageid(const char* value) {
  set_has_messageid();
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageStoreAck.messageId)
}
inline void MessageStoreAck::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageStoreAck.messageId)
}
inline ::std::string* MessageStoreAck::mutable_messageid() {
  set_has_messageid();
  // @@protoc_insertion_point(field_mutable:MessageStoreAck.messageId)
  return messageid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageStoreAck::release_messageid() {
  clear_has_messageid();
  return messageid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageStoreAck::set_allocated_messageid(::std::string* messageid) {
  if (messageid != NULL) {
    set_has_messageid();
  } else {
    clear_has_messageid();
  }
  messageid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messageid);
  // @@protoc_insertion_point(field_set_allocated:MessageStoreAck.messageId)
}

// required bool status = 2 [default = true];
inline bool MessageStoreAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageStoreAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageStoreAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageStoreAck::clear_status() {
  status_ = true;
  clear_has_status();
}
inline bool MessageStoreAck::status() const {
  // @@protoc_insertion_point(field_get:MessageStoreAck.status)
  return status_;
}
inline void MessageStoreAck::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:MessageStoreAck.status)
}

// required string feedback = 3;
inline bool MessageStoreAck::has_feedback() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageStoreAck::set_has_feedback() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageStoreAck::clear_has_feedback() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageStoreAck::clear_feedback() {
  feedback_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_feedback();
}
inline const ::std::string& MessageStoreAck::feedback() const {
  // @@protoc_insertion_point(field_get:MessageStoreAck.feedback)
  return feedback_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageStoreAck::set_feedback(const ::std::string& value) {
  set_has_feedback();
  feedback_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageStoreAck.feedback)
}
inline void MessageStoreAck::set_feedback(const char* value) {
  set_has_feedback();
  feedback_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageStoreAck.feedback)
}
inline void MessageStoreAck::set_feedback(const char* value, size_t size) {
  set_has_feedback();
  feedback_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageStoreAck.feedback)
}
inline ::std::string* MessageStoreAck::mutable_feedback() {
  set_has_feedback();
  // @@protoc_insertion_point(field_mutable:MessageStoreAck.feedback)
  return feedback_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageStoreAck::release_feedback() {
  clear_has_feedback();
  return feedback_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageStoreAck::set_allocated_feedback(::std::string* feedback) {
  if (feedback != NULL) {
    set_has_feedback();
  } else {
    clear_has_feedback();
  }
  feedback_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), feedback);
  // @@protoc_insertion_point(field_set_allocated:MessageStoreAck.feedback)
}

// -------------------------------------------------------------------

// DeliverAck

// required string messageId = 1;
inline bool DeliverAck::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeliverAck::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeliverAck::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeliverAck::clear_messageid() {
  messageid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messageid();
}
inline const ::std::string& DeliverAck::messageid() const {
  // @@protoc_insertion_point(field_get:DeliverAck.messageId)
  return messageid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeliverAck::set_messageid(const ::std::string& value) {
  set_has_messageid();
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeliverAck.messageId)
}
inline void DeliverAck::set_messageid(const char* value) {
  set_has_messageid();
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeliverAck.messageId)
}
inline void DeliverAck::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeliverAck.messageId)
}
inline ::std::string* DeliverAck::mutable_messageid() {
  set_has_messageid();
  // @@protoc_insertion_point(field_mutable:DeliverAck.messageId)
  return messageid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeliverAck::release_messageid() {
  clear_has_messageid();
  return messageid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeliverAck::set_allocated_messageid(::std::string* messageid) {
  if (messageid != NULL) {
    set_has_messageid();
  } else {
    clear_has_messageid();
  }
  messageid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messageid);
  // @@protoc_insertion_point(field_set_allocated:DeliverAck.messageId)
}

// required string topic = 2;
inline bool DeliverAck::has_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeliverAck::set_has_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeliverAck::clear_has_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeliverAck::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic();
}
inline const ::std::string& DeliverAck::topic() const {
  // @@protoc_insertion_point(field_get:DeliverAck.topic)
  return topic_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeliverAck::set_topic(const ::std::string& value) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeliverAck.topic)
}
inline void DeliverAck::set_topic(const char* value) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeliverAck.topic)
}
inline void DeliverAck::set_topic(const char* value, size_t size) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeliverAck.topic)
}
inline ::std::string* DeliverAck::mutable_topic() {
  set_has_topic();
  // @@protoc_insertion_point(field_mutable:DeliverAck.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeliverAck::release_topic() {
  clear_has_topic();
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeliverAck::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    set_has_topic();
  } else {
    clear_has_topic();
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:DeliverAck.topic)
}

// required string messageType = 3;
inline bool DeliverAck::has_messagetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeliverAck::set_has_messagetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeliverAck::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeliverAck::clear_messagetype() {
  messagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagetype();
}
inline const ::std::string& DeliverAck::messagetype() const {
  // @@protoc_insertion_point(field_get:DeliverAck.messageType)
  return messagetype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeliverAck::set_messagetype(const ::std::string& value) {
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeliverAck.messageType)
}
inline void DeliverAck::set_messagetype(const char* value) {
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeliverAck.messageType)
}
inline void DeliverAck::set_messagetype(const char* value, size_t size) {
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeliverAck.messageType)
}
inline ::std::string* DeliverAck::mutable_messagetype() {
  set_has_messagetype();
  // @@protoc_insertion_point(field_mutable:DeliverAck.messageType)
  return messagetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeliverAck::release_messagetype() {
  clear_has_messagetype();
  return messagetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeliverAck::set_allocated_messagetype(::std::string* messagetype) {
  if (messagetype != NULL) {
    set_has_messagetype();
  } else {
    clear_has_messagetype();
  }
  messagetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagetype);
  // @@protoc_insertion_point(field_set_allocated:DeliverAck.messageType)
}

// required string groupId = 4;
inline bool DeliverAck::has_groupid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeliverAck::set_has_groupid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeliverAck::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeliverAck::clear_groupid() {
  groupid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupid();
}
inline const ::std::string& DeliverAck::groupid() const {
  // @@protoc_insertion_point(field_get:DeliverAck.groupId)
  return groupid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeliverAck::set_groupid(const ::std::string& value) {
  set_has_groupid();
  groupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DeliverAck.groupId)
}
inline void DeliverAck::set_groupid(const char* value) {
  set_has_groupid();
  groupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DeliverAck.groupId)
}
inline void DeliverAck::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  groupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DeliverAck.groupId)
}
inline ::std::string* DeliverAck::mutable_groupid() {
  set_has_groupid();
  // @@protoc_insertion_point(field_mutable:DeliverAck.groupId)
  return groupid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeliverAck::release_groupid() {
  clear_has_groupid();
  return groupid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeliverAck::set_allocated_groupid(::std::string* groupid) {
  if (groupid != NULL) {
    set_has_groupid();
  } else {
    clear_has_groupid();
  }
  groupid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupid);
  // @@protoc_insertion_point(field_set_allocated:DeliverAck.groupId)
}

// required bool status = 5 [default = true];
inline bool DeliverAck::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeliverAck::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeliverAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeliverAck::clear_status() {
  status_ = true;
  clear_has_status();
}
inline bool DeliverAck::status() const {
  // @@protoc_insertion_point(field_get:DeliverAck.status)
  return status_;
}
inline void DeliverAck::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:DeliverAck.status)
}

// -------------------------------------------------------------------

// TxACKPacket

// required .Header header = 1;
inline bool TxACKPacket::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxACKPacket::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxACKPacket::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxACKPacket::clear_header() {
  if (header_ != NULL) header_->::Header::Clear();
  clear_has_header();
}
inline const ::Header& TxACKPacket::header() const {
  // @@protoc_insertion_point(field_get:TxACKPacket.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Header* TxACKPacket::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::Header;
  }
  // @@protoc_insertion_point(field_mutable:TxACKPacket.header)
  return header_;
}
inline ::Header* TxACKPacket::release_header() {
  clear_has_header();
  ::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TxACKPacket::set_allocated_header(::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:TxACKPacket.header)
}

// required int32 status = 2 [default = 0];
inline bool TxACKPacket::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxACKPacket::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxACKPacket::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxACKPacket::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 TxACKPacket::status() const {
  // @@protoc_insertion_point(field_get:TxACKPacket.status)
  return status_;
}
inline void TxACKPacket::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:TxACKPacket.status)
}

// required string feedback = 3;
inline bool TxACKPacket::has_feedback() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxACKPacket::set_has_feedback() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxACKPacket::clear_has_feedback() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxACKPacket::clear_feedback() {
  feedback_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_feedback();
}
inline const ::std::string& TxACKPacket::feedback() const {
  // @@protoc_insertion_point(field_get:TxACKPacket.feedback)
  return feedback_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxACKPacket::set_feedback(const ::std::string& value) {
  set_has_feedback();
  feedback_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TxACKPacket.feedback)
}
inline void TxACKPacket::set_feedback(const char* value) {
  set_has_feedback();
  feedback_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TxACKPacket.feedback)
}
inline void TxACKPacket::set_feedback(const char* value, size_t size) {
  set_has_feedback();
  feedback_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TxACKPacket.feedback)
}
inline ::std::string* TxACKPacket::mutable_feedback() {
  set_has_feedback();
  // @@protoc_insertion_point(field_mutable:TxACKPacket.feedback)
  return feedback_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxACKPacket::release_feedback() {
  clear_has_feedback();
  return feedback_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxACKPacket::set_allocated_feedback(::std::string* feedback) {
  if (feedback != NULL) {
    set_has_feedback();
  } else {
    clear_has_feedback();
  }
  feedback_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), feedback);
  // @@protoc_insertion_point(field_set_allocated:TxACKPacket.feedback)
}

// -------------------------------------------------------------------

// Entry

// required string key = 1;
inline bool Entry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entry::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Entry::key() const {
  // @@protoc_insertion_point(field_get:Entry.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entry::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Entry.key)
}
inline void Entry::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Entry.key)
}
inline void Entry::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Entry.key)
}
inline ::std::string* Entry::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:Entry.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entry::release_key() {
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entry::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Entry.key)
}

// required string value = 2;
inline bool Entry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entry::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Entry::value() const {
  // @@protoc_insertion_point(field_get:Entry.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entry::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Entry.value)
}
inline void Entry::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Entry.value)
}
inline void Entry::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Entry.value)
}
inline ::std::string* Entry::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:Entry.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entry::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entry::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:Entry.value)
}

// -------------------------------------------------------------------

// Header

// required string messageId = 1;
inline bool Header::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_messageid() {
  messageid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messageid();
}
inline const ::std::string& Header::messageid() const {
  // @@protoc_insertion_point(field_get:Header.messageId)
  return messageid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_messageid(const ::std::string& value) {
  set_has_messageid();
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Header.messageId)
}
inline void Header::set_messageid(const char* value) {
  set_has_messageid();
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Header.messageId)
}
inline void Header::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Header.messageId)
}
inline ::std::string* Header::mutable_messageid() {
  set_has_messageid();
  // @@protoc_insertion_point(field_mutable:Header.messageId)
  return messageid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_messageid() {
  clear_has_messageid();
  return messageid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_messageid(::std::string* messageid) {
  if (messageid != NULL) {
    set_has_messageid();
  } else {
    clear_has_messageid();
  }
  messageid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messageid);
  // @@protoc_insertion_point(field_set_allocated:Header.messageId)
}

// required string topic = 2;
inline bool Header::has_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic();
}
inline const ::std::string& Header::topic() const {
  // @@protoc_insertion_point(field_get:Header.topic)
  return topic_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_topic(const ::std::string& value) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Header.topic)
}
inline void Header::set_topic(const char* value) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Header.topic)
}
inline void Header::set_topic(const char* value, size_t size) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Header.topic)
}
inline ::std::string* Header::mutable_topic() {
  set_has_topic();
  // @@protoc_insertion_point(field_mutable:Header.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_topic() {
  clear_has_topic();
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    set_has_topic();
  } else {
    clear_has_topic();
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:Header.topic)
}

// required string messageType = 3;
inline bool Header::has_messagetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_messagetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_messagetype() {
  messagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagetype();
}
inline const ::std::string& Header::messagetype() const {
  // @@protoc_insertion_point(field_get:Header.messageType)
  return messagetype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_messagetype(const ::std::string& value) {
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Header.messageType)
}
inline void Header::set_messagetype(const char* value) {
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Header.messageType)
}
inline void Header::set_messagetype(const char* value, size_t size) {
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Header.messageType)
}
inline ::std::string* Header::mutable_messagetype() {
  set_has_messagetype();
  // @@protoc_insertion_point(field_mutable:Header.messageType)
  return messagetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_messagetype() {
  clear_has_messagetype();
  return messagetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_messagetype(::std::string* messagetype) {
  if (messagetype != NULL) {
    set_has_messagetype();
  } else {
    clear_has_messagetype();
  }
  messagetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagetype);
  // @@protoc_insertion_point(field_set_allocated:Header.messageType)
}

// required int64 expiredTime = 4 [default = -1];
inline bool Header::has_expiredtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_expiredtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_expiredtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_expiredtime() {
  expiredtime_ = GOOGLE_LONGLONG(-1);
  clear_has_expiredtime();
}
inline ::google::protobuf::int64 Header::expiredtime() const {
  // @@protoc_insertion_point(field_get:Header.expiredTime)
  return expiredtime_;
}
inline void Header::set_expiredtime(::google::protobuf::int64 value) {
  set_has_expiredtime();
  expiredtime_ = value;
  // @@protoc_insertion_point(field_set:Header.expiredTime)
}

// required int32 deliverLimit = 5 [default = 100];
inline bool Header::has_deliverlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_deliverlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_deliverlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_deliverlimit() {
  deliverlimit_ = 100;
  clear_has_deliverlimit();
}
inline ::google::protobuf::int32 Header::deliverlimit() const {
  // @@protoc_insertion_point(field_get:Header.deliverLimit)
  return deliverlimit_;
}
inline void Header::set_deliverlimit(::google::protobuf::int32 value) {
  set_has_deliverlimit();
  deliverlimit_ = value;
  // @@protoc_insertion_point(field_set:Header.deliverLimit)
}

// required string groupId = 6;
inline bool Header::has_groupid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_groupid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_groupid() {
  groupid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupid();
}
inline const ::std::string& Header::groupid() const {
  // @@protoc_insertion_point(field_get:Header.groupId)
  return groupid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_groupid(const ::std::string& value) {
  set_has_groupid();
  groupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Header.groupId)
}
inline void Header::set_groupid(const char* value) {
  set_has_groupid();
  groupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Header.groupId)
}
inline void Header::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  groupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Header.groupId)
}
inline ::std::string* Header::mutable_groupid() {
  set_has_groupid();
  // @@protoc_insertion_point(field_mutable:Header.groupId)
  return groupid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_groupid() {
  clear_has_groupid();
  return groupid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_groupid(::std::string* groupid) {
  if (groupid != NULL) {
    set_has_groupid();
  } else {
    clear_has_groupid();
  }
  groupid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupid);
  // @@protoc_insertion_point(field_set_allocated:Header.groupId)
}

// required bool commit = 7;
inline bool Header::has_commit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Header::set_has_commit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Header::clear_has_commit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Header::clear_commit() {
  commit_ = false;
  clear_has_commit();
}
inline bool Header::commit() const {
  // @@protoc_insertion_point(field_get:Header.commit)
  return commit_;
}
inline void Header::set_commit(bool value) {
  set_has_commit();
  commit_ = value;
  // @@protoc_insertion_point(field_set:Header.commit)
}

// required bool fly = 8 [default = false];
inline bool Header::has_fly() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header::set_has_fly() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header::clear_has_fly() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header::clear_fly() {
  fly_ = false;
  clear_has_fly();
}
inline bool Header::fly() const {
  // @@protoc_insertion_point(field_get:Header.fly)
  return fly_;
}
inline void Header::set_fly(bool value) {
  set_has_fly();
  fly_ = value;
  // @@protoc_insertion_point(field_set:Header.fly)
}

// repeated .Entry properties = 9;
inline int Header::properties_size() const {
  return properties_.size();
}
inline void Header::clear_properties() {
  properties_.Clear();
}
inline const ::Entry& Header::properties(int index) const {
  // @@protoc_insertion_point(field_get:Header.properties)
  return properties_.Get(index);
}
inline ::Entry* Header::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:Header.properties)
  return properties_.Mutable(index);
}
inline ::Entry* Header::add_properties() {
  // @@protoc_insertion_point(field_add:Header.properties)
  return properties_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Entry >*
Header::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:Header.properties)
  return &properties_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Entry >&
Header::properties() const {
  // @@protoc_insertion_point(field_list:Header.properties)
  return properties_;
}

// -------------------------------------------------------------------

// BytesMessage

// required .Header header = 1;
inline bool BytesMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytesMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytesMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytesMessage::clear_header() {
  if (header_ != NULL) header_->::Header::Clear();
  clear_has_header();
}
inline const ::Header& BytesMessage::header() const {
  // @@protoc_insertion_point(field_get:BytesMessage.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Header* BytesMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::Header;
  }
  // @@protoc_insertion_point(field_mutable:BytesMessage.header)
  return header_;
}
inline ::Header* BytesMessage::release_header() {
  clear_has_header();
  ::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BytesMessage::set_allocated_header(::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:BytesMessage.header)
}

// required bytes body = 2;
inline bool BytesMessage::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytesMessage::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytesMessage::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytesMessage::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_body();
}
inline const ::std::string& BytesMessage::body() const {
  // @@protoc_insertion_point(field_get:BytesMessage.body)
  return body_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesMessage::set_body(const ::std::string& value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BytesMessage.body)
}
inline void BytesMessage::set_body(const char* value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BytesMessage.body)
}
inline void BytesMessage::set_body(const void* value, size_t size) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BytesMessage.body)
}
inline ::std::string* BytesMessage::mutable_body() {
  set_has_body();
  // @@protoc_insertion_point(field_mutable:BytesMessage.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesMessage::release_body() {
  clear_has_body();
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesMessage::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    set_has_body();
  } else {
    clear_has_body();
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:BytesMessage.body)
}

// -------------------------------------------------------------------

// StringMessage

// required .Header header = 1;
inline bool StringMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringMessage::clear_header() {
  if (header_ != NULL) header_->::Header::Clear();
  clear_has_header();
}
inline const ::Header& StringMessage::header() const {
  // @@protoc_insertion_point(field_get:StringMessage.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Header* StringMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::Header;
  }
  // @@protoc_insertion_point(field_mutable:StringMessage.header)
  return header_;
}
inline ::Header* StringMessage::release_header() {
  clear_has_header();
  ::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void StringMessage::set_allocated_header(::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:StringMessage.header)
}

// required string body = 2;
inline bool StringMessage::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringMessage::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringMessage::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringMessage::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_body();
}
inline const ::std::string& StringMessage::body() const {
  // @@protoc_insertion_point(field_get:StringMessage.body)
  return body_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringMessage::set_body(const ::std::string& value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:StringMessage.body)
}
inline void StringMessage::set_body(const char* value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:StringMessage.body)
}
inline void StringMessage::set_body(const char* value, size_t size) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:StringMessage.body)
}
inline ::std::string* StringMessage::mutable_body() {
  set_has_body();
  // @@protoc_insertion_point(field_mutable:StringMessage.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringMessage::release_body() {
  clear_has_body();
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringMessage::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    set_has_body();
  } else {
    clear_has_body();
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:StringMessage.body)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kite_5fremoting_2eproto__INCLUDED
